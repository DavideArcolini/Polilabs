#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/rand.h>
#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/rsa.h>

#define N_BITS 128
#define RSA_BITS 2048
#define EXPONENT RSA_F4

/**
 * @brief Handle errors generated by openssl
 * 
 */
void handle_errors (void) {
    ERR_print_errors_fp(stderr);
    exit(EXIT_FAILURE);
}

void BN_formatted_print (FILE *fp, BIGNUM *bignum, char *title) {
    fprintf(stdout, "> %s: ", title);
    BN_print_fp(stdout, bignum);
    fprintf(stdout, "\n");
}

int CRAZY (void) {
    
    /* 1) Generate two random 128-bit integers */
    BIGNUM *rand1 = BN_new();
    BIGNUM *rand2 = BN_new();
    if (!BN_rand(rand1, N_BITS, -1, 0) || !BN_rand(rand2, N_BITS, -1, 0)) {
        handle_errors();
    }
    BN_formatted_print(stdout, rand1, "rand1");
    BN_formatted_print(stdout, rand2, "rand2");

    /* 2) Obtaining keys */
    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *sum = BN_new();
    BIGNUM *sub = BN_new();
    BIGNUM *mul = BN_new();
    BIGNUM *mod = BN_new();
    BIGNUM *bas = BN_new();
    BIGNUM *exp = BN_new();
    BIGNUM *key1 = BN_new();
    BIGNUM *key2 = BN_new();

    if (!BN_dec2bn(&bas, "2") || !BN_dec2bn(&exp, "128") || !BN_exp(mod, bas, exp, ctx)) {
        handle_errors();
    }
    // BN_formatted_print(stdout, mod, "mod");
    
    if (!BN_add(sum, rand1, rand2) || !BN_sub(sub, rand1, rand2) || !BN_mul(mul, rand1, rand2, ctx)) {
        handle_errors();
    }
    // BN_formatted_print(stdout, sum, "rand1 + rand2");
    // BN_formatted_print(stdout, sub, "rand1 - rand2");
    // BN_formatted_print(stdout, mul, "rand1 * rand2"); 
    
    if (!BN_div(key2, NULL, mul, sub, ctx) || !BN_mul(key1, sum, sub, ctx)) {      
        handle_errors();
    }
    BN_formatted_print(stdout, key1, "key1 (before mod)");
    BN_formatted_print(stdout, key2, "key2 (before mod)"); 
    
    if (!BN_mod(key1, key1, mod, ctx) || !BN_mod(key2, key2, mod, ctx)) {
        handle_errors();
    }
    BN_formatted_print(stdout, key1, "key1 (after mod)");
    BN_formatted_print(stdout, key2, "key2 (after mod)");


    /* 3) Encryption (AES_CBC - 128-bits block_size) */
    BIGNUM *iv = BN_new();
    BN_dec2bn(&iv, "ECE0332A78DE9BE162F938909B024650"); // random or suppose to have it already
    char *IV = BN_bn2hex(iv);
    char *key1_c = BN_bn2hex(key1);
	char *key2_c = BN_bn2hex(key2);
    fprintf(stdout, "> key1: %s\n", key1_c);
    fprintf(stdout, "> key2: %s\n", key2_c);

    EVP_CIPHER_CTX *AES_ctx = EVP_CIPHER_CTX_new();
    if (AES_ctx == NULL || !EVP_CipherInit(AES_ctx, EVP_aes_128_cbc(), key1_c, IV, 1)) {
        handle_errors();
    }

    int update_length;
    int key2_enc_length;
    char *key2_enc = (char *) malloc((strlen(key2_c) + 16) * sizeof(char));
    if (key2_enc == NULL) {
        fprintf(stderr, "[ERROR] malloc() failed execution\n");
        return 0;
    }

    if (!EVP_CipherUpdate(AES_ctx, key2_enc, &update_length, key2_c, strlen(key2_c))) {
        handle_errors();
    }
    key2_enc_length += update_length;
    if (!EVP_CipherFinal(AES_ctx, key2_enc+key2_enc_length, &update_length)) {
        handle_errors();
    }
    key2_enc_length += update_length;
    fprintf(stdout, "> encrypted key2: %s\n", key2_enc);
    
    /* 4) Encryption (RSA) */
    RSA *RSA_PrivateKey = RSA_new();
    BIGNUM *exponent = BN_new();
    
    if (!BN_set_word(exponent, EXPONENT)) {
        handle_errors();
    }
    if (!RSA_generate_key_ex(RSA_PrivateKey, RSA_BITS, exponent, NULL)) {
        handle_errors();
    }

    int key2_enc_RSA_length;
    char *key2_enc_RSA = (char *) malloc(RSA_size(RSA_PrivateKey) * sizeof(char));
    if (key2_enc_RSA == NULL) {
        fprintf(stderr, "[ERROR] malloc() failed execution\n");
        return 0;
    }

    key2_enc_RSA_length = RSA_public_encrypt(strlen(key2_enc)+1, key2_enc, key2_enc_RSA, RSA_PrivateKey, RSA_PKCS1_OAEP_PADDING);
    fprintf(stdout, "> Final (encrypted) key is: %s\n", key2_enc_RSA);
    
    return 1;
}

int main(int argc, char *argv[]) {

    /* Checking input arguments */
    if (argc != 1) {
        fprintf(stderr, "[USAGE] ./exe01\n");
        exit(EXIT_FAILURE);
    }

    /* Load the human readable error strings for libcrypto */
    ERR_load_crypto_strings();
    /* Load all digest and cipher algorithms */
    OpenSSL_add_all_algorithms();    

    /* Executing protocol */
    if (!CRAZY()) {
        fprintf(stderr, "[ERROR] protocols failed!\n");
        exit(EXIT_FAILURE);
    }

    /* completely free all the cipher data */
    CRYPTO_cleanup_all_ex_data();
    /* Remove error strings */
    ERR_free_strings();

    /* Program executed correctly */
    exit(EXIT_SUCCESS);
}